<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Tutoriel ULTIME : API REST en Go (Clean Architecture, Prisma, JWT, Tests)</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 2em; background: #ffffff; color: #333; }
        pre, code { background: #f4f4f4; padding: 0.2em 0.4em; border-radius: 4px; font-family: Consolas, 'Courier New', monospace; overflow-x: auto;}
        h1 { color: #880e4f; border-bottom: 3px solid #c2185b; padding-bottom: 0.3em; }
        h2 { color: #e91e63; margin-top: 1.5em; border-left: 5px solid #ff4081; padding-left: 0.5em; }
        h3 { color: #f06292; margin-top: 1em; }
        ul { list-style-type: disc; margin-left: 20px; }
        .file-box { background: #fce4ec; padding: 1em; border-radius: 8px; margin-bottom: 1.5em; border: 1px solid #f8bbd0; }
        .warning { color: #c62828; font-weight: bold; background: #ffebee; padding: 0.5em; border-radius: 4px; margin-top: 1em; }
        .note { color: #388e3c; font-style: italic; background: #e8f5e9; padding: 0.5em; border-radius: 4px; margin-top: 1em; }
        .code-title { font-weight: bold; color: #880e4f; margin-bottom: 0.5em; }
    </style>
</head>
<body>
    <h1>Tutoriel ULTIME : API REST en Go avec Architecture Modulaire, SÃ©curitÃ© et Robustesse</h1>

    <p class="note">Ce guide est votre rÃ©fÃ©rence complÃ¨te, couvrant l'architecture, la sÃ©curitÃ© (JWT, Bcrypt, RÃ´les), les fonctionnalitÃ©s avancÃ©es (Pagination, Filtrage) et la robustesse (Validation, Gestion des Erreurs, Tests). Adaptable Ã  **tout projet** d'API REST en Go utilisant <code>chi</code> et <code>Prisma Client Go</code>.</p>

    <h2>1. ğŸ› ï¸ Outils, PrÃ©requis et DÃ©pendances Cruciales</h2>

    <ul>
        <li>**Go** : Langage de base (performance, concurrence).</li>
        <li>**Prisma Client Go** : Couche d'accÃ¨s aux donnÃ©es (ORM type-safe).</li>
        <li>**chi** : Routeur HTTP.</li>
        <li>**Bcrypt** : Pour le **hachage** des mots de passe.</li>
        <li>**jwtauth/v5** : Pour l'implÃ©mentation du **JWT**.</li>
        <li>**go-playground/validator/v10** : Pour la **validation** des DTOs.</li>
        <li>**go-chi/host-limiter** : **(NOUVEAU)** Pour le **Rate Limiting** (limitation de dÃ©bit).</li>
        <li>**swaggo** (Optionnel) : **(NOUVEAU)** Pour la **Documentation** OpenAPI.</li>
    </ul>

    <h2>2. ğŸ—ï¸ Architecture Modulaire (InspirÃ©e de Clean/Hexagonal)</h2>
    <p>L'objectif : sÃ©parez la logique mÃ©tier (Services) des dÃ©tails techniques (Prisma/DB).</p>
    <div class="file-box">
        <pre>
api/
 â”œâ”€â”€ internal/
 â”‚    â”œâ”€â”€ domain/            <span class="note">// 1. Le CÅ“ur : EntitÃ©s et Interfaces de Repository (Contrats)</span>
 â”‚    â”‚    â”œâ”€â”€ user.go        <span class="note">// Structures (Model) et Interfaces. Ex: UserRepository interface</span>
 â”‚    â”œâ”€â”€ infrastructure/    <span class="note">// 2. L'Infrastructure : ImplÃ©mentation technique</span>
 â”‚    â”‚    â”œâ”€â”€ db/            <span class="note">// Code gÃ©nÃ©rÃ© par Prisma</span>
 â”‚    â”‚    â””â”€â”€ repository/    <span class="note">// ImplÃ©mentation du UserRepository avec Prisma</span>
 â”‚    â”œâ”€â”€ application/       <span class="note">// 3. La Logique : Cas d'utilisation (Services/Use Cases)</span>
 â”‚    â”‚    â””â”€â”€ user_service.go  <span class="note">// Contient la logique mÃ©tier pure (interagit avec domain/user.go)</span>
 â”‚    â””â”€â”€ delivery/          <span class="note">// 4. Le Transport : Couche HTTP</span>
 â”‚         â”œâ”€â”€ http/
 â”‚         â”‚    â”œâ”€â”€ handlers/      <span class="note">// Logique HTTP (Validation, Erreurs, DTO, Service calls)</span>
 â”‚         â”‚    â””â”€â”€ middleware/    <span class="note">// JWT, RÃ´le, Rate Limiter</span>
 â”‚         â””â”€â”€ routes/
 â”œâ”€â”€ pkg/                     <span class="note">// Utilitaires rÃ©utilisables</span>
 â”‚    â””â”€â”€ errors/              <span class="note">// **NOUVEAU** Gestion des erreurs structurÃ©es</span>
 â””â”€â”€ main.go                  <span class="note">// Initialisation et DÃ©marrage du serveur</span>
        </pre>
    </div>

    <h2>3. ğŸ’¥ Robustesse : Gestion des Erreurs UniformisÃ©e</h2>
    <p>Toutes les erreurs de l'API doivent avoir un format cohÃ©rent.</p>
    <div class="file-box">
        <div class="code-title">pkg/errors/errors.go (DÃ©finition des Erreurs)</div>
        <pre>
package errors

import "net/http"

// APIError est la structure standard pour les erreurs retournÃ©es au client
type APIError struct {
    Status  int    `json:"status"`
    Message string `json:"message"`
    Code    string `json:"code,omitempty"`
}

func (e *APIError) Error() string {
    return e.Message
}

// Erreur de validation (400)
var ErrValidation = &APIError{
    Status: http.StatusBadRequest, 
    Message: "Erreur de validation des donnÃ©es.", 
    Code: "VALIDATION_ERROR",
}

// Erreur Non TrouvÃ© (404)
var ErrNotFound = &APIError{
    Status: http.StatusNotFound, 
    Message: "Ressource non trouvÃ©e.", 
    Code: "NOT_FOUND",
}

// Erreur Non AutorisÃ© (403)
var ErrForbidden = &APIError{
    Status: http.StatusForbidden, 
    Message: "AccÃ¨s refusÃ©. RÃ´le insuffisant.", 
    Code: "FORBIDDEN",
}
        </pre>
        <div class="code-title">delivery/http/utils/response.go (Fonction de rÃ©ponse)</div>
        <pre>
// ...
func RespondError(w http.ResponseWriter, err error) {
    if apiErr, ok := err.(*errors.APIError); ok {
        // Si c'est une erreur API structurÃ©e
        w.WriteHeader(apiErr.Status)
        json.NewEncoder(w).Encode(apiErr)
    } else {
        // Erreur serveur inconnue (500)
        w.WriteHeader(http.StatusInternalServerError)
        json.NewEncoder(w).Encode(map[string]interface{}{
            "status":  http.StatusInternalServerError,
            "message": "Erreur interne du serveur.",
        })
    }
}
        </pre>
    </div>

    <h2>4. ğŸ”’ SÃ©curitÃ© AvancÃ©e : Rate Limiting et RÃ´les</h2>

    <h3>4.1. Middleware de Taux Limite (Rate Limiting)</h3>
    <p>EmpÃªche les abus ou les attaques DDOS lÃ©gÃ¨res en limitant les requÃªtes par IP.</p>
    <div class="file-box">
        <div class="code-title">main.go (Initialisation dans le routeur)</div>
        <pre>
// ImplÃ©mentation simple avec go-chi/host-limiter (Ã  adapter en production)
import "github.com/go-chi/host-limiter"

// ... dans func main() ...
limiter := hlimit.NewHostLimiter(
    hlimit.PerIP(50, time.Minute), // 50 requÃªtes max par IP par minute
    hlimit.WithErrorHandler(func(w http.ResponseWriter, r *http.Request) {
        utils.RespondError(w, errors.NewAPIError(http.StatusTooManyRequests, "Limite de requÃªtes dÃ©passÃ©e."))
    }),
)

r := chi.NewRouter()
r.Use(limiter.Handler) // Applique le Rate Limiter sur toutes les routes
// ... autres middlewares ...
        </pre>
    </div>

    <h3>4.2. Authentification et ContrÃ´le d'AccÃ¨s par RÃ´le (Mis Ã  jour)</h3>
    <p>Le middleware **RoleMiddleware** utilise les erreurs structurÃ©es :</p>
    <div class="file-box">
        <div class="code-title">delivery/http/middleware/auth.go (RoleMiddleware)</div>
        <pre>
// ...
func RoleMiddleware(requiredRoles ...db.Role) func(next http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // ... (logique de rÃ©cupÃ©ration des claims du JWT) ...
            
            // Si le token est invalide ou manquant
            if err != nil {
                utils.RespondError(w, errors.ErrUnauthorized) // Erreur 401 structurÃ©e
                return
            }
            
            // ... (logique de vÃ©rification du rÃ´le) ...

            if !isAuthorized {
                utils.RespondError(w, errors.ErrForbidden) // Erreur 403 structurÃ©e
                return
            }

            next.ServeHTTP(w, r)
        })
    }
}
        </pre>
    </div>

    <h2>5. ğŸ”„ CRUD AvancÃ© : Pagination et Filtrage Universel</h2>
    <p>Pour des requÃªtes de liste efficaces, quel que soit le modÃ¨le (User, Product, Post).</p>

    <h3>5.1. DTO de RequÃªte GÃ©nÃ©rique</h3>
    <div class="file-box">
        <div class="code-title">delivery/http/handlers/common_dtos.go</div>
        <pre>
package handlers

// ListQuery DTO pour la pagination, le tri et le filtrage (Query Params)
type ListQuery struct {
    Page  int    `json:"page" validate:"min=1"`
    Limit int    `json:"limit" validate:"min=1,max=100"`
    Sort  string `json:"sort"` // Ex: "createdAt:desc"
    Filter string `json:"filter"` // Ex: "role:ADMIN,isActive:true"
}

// Utilisation dans le Handler
// query := parseListQuery(r) // Helper qui lit les params de l'URL

// Dans le Service, cela se traduit par :
// client.User.FindMany(
//     db.User.Role.Equals(db.Role(filter.Role)), // Filtrage
// ).Take(query.Limit).Skip((query.Page - 1) * query.Limit).Exec(ctx) // Pagination
        </pre>
    </div>

    <h2>6. ğŸ§ª Tests : Assurer la StabilitÃ© du Code</h2>
    <p>La **Clean Architecture** rend les tests unitaires simples car la logique mÃ©tier est isolÃ©e.</p>

    <h3>6.1. Tests Unitaires de Logique MÃ©tier (Services)</h3>
    <p>Testez les `services/` **sans** dÃ©pendre du client Prisma (base de donnÃ©es). Pour cela, vous utilisez l'Interface `UserRepository` (du dossier `domain/`) et vous crÃ©ez un **Mock** (une fausse implÃ©mentation) de cette interface dans votre test.</p>
    <div class="file-box">
        <div class="code-title">application/user_service_test.go</div>
        <pre>
package application_test

import (
    "context"
    "testing"
    "api/internal/domain"
    "api/internal/application"
    // Mock Repository (doit Ãªtre crÃ©Ã© manuellement ou avec un outil)
)

func TestCreateUser(t *testing.T) {
    // 1. Arrange: CrÃ©er un Mock de UserRepository
    mockRepo := &MockUserRepository{}
    mockRepo.On("Create", mock.Anything, mock.Anything).Return(&domain.User{ID: "123"}, nil)
    
    // 2. Initialiser le Service avec le Mock
    userService := application.NewUserService(mockRepo)
    
    // 3. Act: Appeler la mÃ©thode Ã  tester
    user, err := userService.CreateUser(context.Background(), "test@test.com", "pass123")
    
    // 4. Assert: VÃ©rifier le rÃ©sultat
    if err != nil {
        t.Errorf("CreateUser a Ã©chouÃ©: %v", err)
    }
    if user.ID != "123" {
        t.Errorf("ID inattendu: %s", user.ID)
    }
    mockRepo.AssertExpectations(t) // VÃ©rifie que la mÃ©thode Create a bien Ã©tÃ© appelÃ©e
}
        </pre>
    </div>

    <h3>6.2. Tests d'IntÃ©gration (Handlers)</h3>
    <p>Simulez une requÃªte HTTP sur votre routeur sans dÃ©marrer le serveur.</p>
    <div class="file-box">
        <div class="code-title">delivery/http/handlers/user_handler_test.go</div>
        <pre>
import (
    "net/http"
    "net/http/httptest"
    "testing"
    "github.com/go-chi/chi/v5"
    // ...
)

func TestListUsersHandler(t *testing.T) {
    // 1. Arrange: CrÃ©er un faux service Ã  retourner
    // mockService := ...
    
    // 2. Configurer le Handler
    handler := handlers.ListUsersHandler(mockService)

    // 3. CrÃ©er une fausse requÃªte (Request et Response Recorder)
    req, _ := http.NewRequest("GET", "/users?limit=10", nil)
    rr := httptest.NewRecorder()

    // 4. Act: Servir la requÃªte
    handler.ServeHTTP(rr, req)

    // 5. Assert: VÃ©rifier le code de rÃ©ponse
    if status := rr.Code; status != http.StatusOK {
        t.Errorf("Attendu %v, Obtenu %v", http.StatusOK, status)
    }
    // ... VÃ©rifier le contenu JSON ...
}
        </pre>
    </div>

    <h2>7. ğŸ“ Documentation (Swagger / OpenAPI)</h2>
    <p>Pour tout projet professionnel, la documentation est indispensable. L'outil le plus courant pour Go est <code>swaggo</code>.</p>
    <ul>
        <li>Installez <code>go get github.com/swaggo/swag/cmd/swag</code>.</li>
        <li>Ajoutez des commentaires spÃ©cifiques (<code>// @Router /users [get]</code>, <code>// @Success 200 {array} models.User</code>) au-dessus de chaque handler.</li>
        <li>Lancez <code>swag init</code> pour gÃ©nÃ©rer le fichier <code>docs/swagger.json</code>.</li>
        <li>Ajoutez une route pour servir l'interface Swagger (gÃ©nÃ©ralement via un middleware comme <code>github.com/swaggo/http-swagger</code>).</li>
    </ul>

    <p class="warning">Ce guide est dÃ©sormais complet, couvrant de l'initialisation au dÃ©ploiement (via l'architecture) et la sÃ©curitÃ© avancÃ©e, et devrait servir de base solide pour n'importe quel projet d'API REST en Go.</p>
</body>
</html>